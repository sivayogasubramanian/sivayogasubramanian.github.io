---
layout: post
title: Compilation Steps in C++
description: Digging into the complexities of compiling C++ code
categories:
  - compilation
tags:
  - c++
date: 2024-10-15 15:09 +0800
---

## Background

I had to write some C++ code for work recently. The project used some open source libraries which meant that compile command is not so straightforward. A quick ChatGPT search later, I found out that I had to inlcude some `-I` flags for the include directories and `-L` flags for the library directories. I also had to link the libraries using `-l` flags. This got me thinking about the compilation steps in C++ because I had no idea what those flags meant and why they were necessary. So I decided to dig deeper into the compilation process of C++ code.

## Introduction

C++ is a compiled language which means that the code you write needs to be converted into machine code before it can be executed. The process of converting the source code into machine code is called compilation. The compilation process in C++ can be broken down into several steps. In this post, we will explore these steps in detail.

## Preprocessing

The first step in the compilation process is preprocessing. The preprocessor is a program that processes the source code before it is compiled. It performs tasks such as including header files, expanding macros, and removing comments. The preprocessor is invoked by the compiler using the `-E` flag.The output of the preprocessor is a file which contains the preprocessed source code.

```sh
clang++ -std=c++11 -E example.cpp -o example_pre.cpp
```

The preprocessor's behavior can be controlled using preprocessor directives. Preprocessor directives are special commands that begin with a `#` symbol. Some common preprocessor directives include `#include`, `#define`, and `#ifdef`.

For example, one common use of the preprocessor (apart from include and define) is conditional compilation. Conditional compilation allows you to include or exclude certain parts of the code based on preprocessor directives. This can be useful for debugging or for creating platform-specific code.

```cpp
#ifdef DEBUG
    // Debugging code
#endif

#ifdef PLATFORM_WINDOWS
    // Windows-specific code
#endif
```

A quick look at the `.i` file generated by the preprocessor can give you a better understanding of how the preprocessor works and how it transforms the source code. Usually, it is much larger than the original source code because it includes all the header files and expands all the macros.

## Compilation

The next step in the compilation process is compilation. The compiler takes the preprocessed source code and translates it into assembly code. The assembly code is a low-level representation of the source code that is specific to the target architecture. The compiler is responsible for generating efficient and optimized assembly code.

The compiler is invoked using the `-S` flag. The output of the compiler is a file with the `.s` extension which contains the assembly code.

```sh
clang++ -std=c++11 -S example_pre.cpp -o example_asm.s
```

The assembly code generated by the compiler can be quite complex and difficult to read. It consists of instructions that are specific to the target architecture and are represented in a human-readable format. Understanding assembly code is not necessary for most C++ programmers, but it can be useful for debugging or performance optimization.

## Assembly

The next step in the compilation process is assembly. The assembler is a program that takes the assembly code generated by the compiler and translates it into machine code. The machine code is a binary representation of the assembly code that can be executed by the CPU.

The assembler is invoked using the `-c` flag. The output of the assembler is an object file with the `.o` extension which contains the machine code.

```sh
clang++ -std=c++11 -c example_asm.s -o example_obj.o
```

## Linking

The final step in the compilation process is linking. The linker is a program that takes the object files generated by the assembler and combines them into an executable file. The linker is responsible for resolving external references, linking libraries, and generating the final executable.

The linker is invoked using the `-o` flag. The output of the linker is an executable file that can be run on the target platform.

```sh
clang++ -std=c++11 example_obj.o -o example
```

The linker also allows you to specify additional libraries and directories using the `-l` and `-L` flags. The `-l` flag is used to link libraries, while the `-L` flag is used to specify library directories. There is also the `-I` flag which is used to specify include directories.

```sh
clang++ -std=c++11 example_obj.o -o example -L/path/to/lib -I/path/to/include -lmylib
```

## One Step Compilation

You can also compile and link your code in a single step using the `-o` flag. This is the most common way to compile C++ code.

```sh
clang++ -std=c++11 example.cpp -o example
```

Behind the scenes, the compiler invokes the preprocessor, compiler, assembler, and linker to generate the final executable. This is a convenient way to compile your code without having to worry about the intermediate steps.

## Conclusion

In this post, we explored the compilation process of C++ code. We learned about the preprocessing, compilation, assembly, and linking steps involved in compiling C++ code. Understanding the compilation process can help you write more efficient and optimized code. It can also help you debug and troubleshoot issues that may arise during compilation. I hope this post has given you a better understanding of how C++ code is compiled and executed.
